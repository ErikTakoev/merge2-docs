# Релокація Фішок (Chip Relocation)

[← На Головну](../README.md) | [← Багато-клітинні Фішки](MultiCellChip.md)

Релокація — це механізм автоматичного переміщення фішок, що заважають, у сусідні вільні клітинки для звільнення місця під нову або переміщувану фішку. Це критично важлива система для підтримки геймплею з багато-клітинними фішками.

## Проблема
У грі з фішками різного розміру (1x1, 1x2, 2x2 тощо) часто виникають ситуації конфлікту простору:
1. **Злиття (Merge)**: Дві фішки 1x1 зливаються у фішку 1x2, якій потрібно більше місця.
2. **Перетягування (Drag)**: Гравець намагається поставити велику фішку у простір, де частково знаходяться інші фішки.

Без релокації гравцеві довелося б вручну розчищати місце, що погіршує UX.

## Технічна Реалізація

За логіку релокації відповідає клас `ChipMovingLogic`, який реалізує інтерфейс `IChipMovingLogic`.

### Алгоритм `CanChipMoving`

Процес перевірки можливості переміщення та планування релокації відбувається наступним чином:

1. **Валідація Цільової Позиції**:
   - Система перевіряє, чи взагалі валідна цільова клітинка (`leftTopCell`) для розміщення фішки заданого розміру (`fieldGrid.IsValidCellPos`).

2. **Визначення Конфліктів**:
   - Метод `GetOccupiedCellsInArea` знаходить усі фішки, що наразі займають клітинки в зоні, куди хоче стати нова фішка.
   - Створюється список унікальних фішок для потенційного переміщення (`chipsToPotentiallyMove`).

3. **Сортування Пріоритетів**:
   - Фішки для переміщення сортуються за розміром (площею) у спадному порядку: `(bSize.x * bSize.y) - (aSize.x * aSize.y)`.
   - **Причина**: Великі фішки важче розмістити, тому для них шукають місце в першу чергу, щоб мінімізувати фрагментацію поля.

4. **Планування Переміщень (Simulation)**:
   - Створюється `plannedRelocations` — список запланованих дій.
   - Створюється набір `unavailableCellsForRelocation`, куди одразу додаються клітинки, що будуть зайняті новою фішкою.
   - Для кожної конфліктної фішки викликається `freeCellFinder.FindNearestFreeCell`.
   - **Важливо**: Якщо знайдено нове місце, його клітинки також додаються до `unavailableCellsForRelocation`, щоб наступні фішки в цьому ж циклі не намагалися зайняти те саме місце.

5. **Атомарність**:
   - Якщо хоча б для однієї конфліктної фішки не знайдено вільного місця, весь процес вважається неможливим (`return false`), і жодних змін на полі не відбувається.

### Виконання Релокації (`ChipsRelocate`)

Якщо `CanChipMoving` повернув `true`, виконується метод `ChipsRelocate`:
1. **Очищення**: З клітинок прибираються посилання на фішку, що рухається (Source), та всі фішки, що будуть релоковані.
2. **Переміщення**:
   - Фішки, що релокуються, отримують нові координати.
   - Їм тимчасово встановлюється стан `SetDragging(true)` для візуальної коректності (сортування шарів).
   - Оновлюється сітка (`fieldGrid.SetChipInCell`).
3. **Розміщення Головної Фішки**: Фішка, що ініціювала процес, ставиться на своє нове місце.

## Взаємодія з Іншими Системами

### 1. Drag & Drop
При завершенні перетягування (`OnDragEnd` в `DraggableChipLogic`):
- Викликається `ChipMovingLogic.ChipMoving`.
- Якщо релокація можлива, фішки "розсуваються".
- Якщо ні — фішка, яку тягнув гравець, повертається на попереднє місце ("snap back").

### 2. Merge (Злиття)
При злитті, коли фішка еволюціонує і збільшується в розмірі:
- Система перевіряє, чи вистачить місця для нової форми.
- Якщо ні — запускається пошук місця для сусідів.
- Це дозволяє фішці "вирости", посунувши оточення.

## Використані Структури
```csharp
public struct ChipMoveAction
{
    public Chip ChipToMove;
    public Cell FromCell; // Початкова MainCell
    public Cell ToCell;   // Цільова MainCell
}
```
