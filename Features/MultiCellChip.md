# Багато-клітинні Фішки (Multi-cell Chips)

[← На Головну](../Main.md) | [Механіка Релокації →](ChipRelocation.md)

Особливість проекту — підтримка фішок, що займають більше однієї клітинки сітки (наприклад, 1x2, 2x2). Це додає значний шар складності до всіх механік гри, від рендерингу до логіки переміщення.

## Технічна Структура

### Визначення Розміру
Розмір фішки визначається в `ChipData` властивістю `Vector2Int Size`.
- Мінімальний розмір: 1x1.
- Орієнтація: `x` - ширина (стовпці), `y` - висота (рядки).
- **Валідація**: При завантаженні `OnEnable` гарантується, що розміри не менші за одиницю.

### Якірна Система (Top-Left Anchor)
Для спрощення позиціонування використовується система "якоря":
- **Main Cell (Anchor)**: Логічна позиція фішки завжди прив'язана до *лівої верхньої* клітинки займаної області.
- **Secondary Cells**: Решта клітинок, які покриває фішка.
- У класі `Chip` немає списку всіх клітинок. Натомість, ***Field Grid*** відповідає за те, щоб у всіх клітинках, які покриває фішка, було посилання на цей `Chip`.

### Grid Occupancy (Заповнення Сітки)
Коли фішка розміщується на позиції `(x, y)` з розміром `(w, h)`:
1. Система перевіряє межі сітки та зайнятість усіх клітинок в діапазоні `[x ... x+w-1, y ... y+h-1]`.
2. У кожну клітинку цього діапазону записується посилання на екземпляр `Chip`.
3. Це дозволяє миттєво отримувати доступ до фішки, натиснувши на будь-яку її частину.

## Технічні Складності та Рішення

### 1. Валідація Позиції
**Складність**: Перевірка "чи вільна клітинка" для 1x1 тривіальна. Для NxM потрібно перевіряти область.
**Рішення**:
- Метод `IFieldGrid.IsValidCellPos(Vector2Int pos, Vector2Int size)`.
- Перевіряє вихід за межі масиву для *всіх* потенційних клітинок.
- Перевіряє, чи клітинки не є заблокованими (якщо є механіка перешкод).

### 2. Взаємодія (Input Redirection)
**Складність**: Гравець може натиснути (Tap) або почяти драг (Drag) за "хвіст" великої фішки (вторинну клітинку).
**Рішення**:
- Кожна `Cell` має поле `Chip`.
- При будь-якій взаємодії з клітинкою, логіка працює з отриманим посиланням на `Chip`.
- Для операцій переміщення завжди обчислюється **Main Cell** (як `currentCell.Position - relativeOffset`), або ж `Chip` сам зберігає своє положення відносно якоря.
- У поточній реалізації, `Cell` знає свій `Chip`, а методи переміщення (`MoveTo`) оперують цільовою `MainCell`.

### 3. Конфлікти Простору (Relocation)
**Складність**: При переміщенні великої фішки вона може зачепити кілька менших фішок. Просте правило "swap" (поміняти місцями) тут не працює, бо фішок багато, і вони можуть не влізти на старе місце великої фішки.
**Рішення**: Винесено в окрему складну систему **[Chip Relocation](ChipRelocation.md)**, яка шукає вільні місця для всіх постраждалих сусідів.


## Взаємодія з Геймплеєм

### Злиття у Більшу Фішку (Growth Merge)
Особливий випадок злиття, коли результат має більший розмір, ніж вихідні фішки (наприклад, 1x1 + 1x1 -> 2x2).

**Алгоритм (`MergeableChipLogic`):**
1. **Перевірка Меж (Bounds check)**: Якщо нова фішка виходить за межі поля (наприклад, злиття відбувається у крайньому правому стовпці), система обчислює нову позицію якоря (`newCellPosition`), фактично зсуваючи фішку в межі поля.
2. **Перевірка Релокації**:
   - Викликається `chipMovingLogic.CanChipMoving` для нової форми фішки.
   - У список виключень (`chipsToExclude`) додаються обидві фішки, що беруть участь у злитті (адже вони зникнуть).
3. **Результат**:
   - **Успіх**: Якщо знайдено місце для нової фішки (і для всіх сусідів, яких треба посунути), старі фішки знищуються, сусіди релокуються, і створюється нова фішка.
   - **Відміна (Rollback)**: Якщо релокація неможлива (немає місця для сусідів), злиття скасовується (`return false`), і фішки залишаються на своїх місцях. Гравець бачить, що злиття не відбулося.

- **Спавн**: Генератори (`ChipGenerator`) повинні враховувати розмір фішки, яку спавнять. Якщо на виході немає місця для 2x2, спавн блокується, навіть якщо центральна клітинка вільна.
- **Merge**: Результат злиття успадковує позицію (Anchor) тієї фішки, *на яку* кинули іншу. Це важливо для передбачуваності результату.
